# -*- coding: utf-8 -*-
"""random_csp.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/17R-6aiNB9-do0U7A99gJ4_2o6rq9qWJW

# Binary CSP

Random generation of Binary CSP instances as specified by the model RB proposed in [1]. The choice of this model is motivated by the fact that it has exact phase transition and the ability to generate asymp-totically hard instances. Each CSP instance are generated using the parameters n, p, α and r where n is the number of variables, p (0 < p < 1) is the constraint tightness, and r and α (0 < r, α < 1) are two positive constants used by the model RB [1].

1. Select with repetition rn ln n random constraints. Each random constraint is formed by selecting
without repetition 2 of n variables.
2. For each constraint we uniformly select without repetition pd2
incompatible pairs of values, where d = n α is the domain size of each variable.
3. All the variables have the same domain corresponding to the first d natural numbers (0 . . . d − 1).
According to [1], the phase transition pt is calculated as follows: pt = 1 − e −α/r. Solvable problems are therefore generated with p < pt.

## Search Strategies

1.   BT Standard Backtracking.
2.   FC Forward Checking.
3.   FLA Full Look Ahead (also called MAC).
"""

class randomCSP:
  #initialize the class
    def __init__(self, nVariables, cTightness, alpha, beta):
      #class attributes for n, p, α and r
      self.nVariables = int(nVariables)
      self.cTightness = float(cTightness)
      self.alpha = float(alpha)
      self.beta = float(beta)
    
    
                      
#calculate the domain size, number of constraints and number of incompactible tuples
    def computValues(self):
      import math
      domainSize =  int(self.nVariables)**float(self.alpha)
      numberOfConstraints = (float(self.beta)* int(self.nVariables))*(math.log(int(self.nVariables)))
      numberOfIncompactibleTuples = float(self.cTightness)*(round(domainSize)**2)

      return domainSize, numberOfConstraints, numberOfIncompactibleTuples 

      
#generates the unique variables required
    def generateVariables(self, nVariables):
      count = 0
      variables = set()

      while count < nVariables:
          variables.add("X"+str(count))
          count+=1
      return variables 

#generates the domains from the domain size
    def generateDomain(self,numdomains):
        count = 0
        domains = set()

        while count < round(domainSize):
            domains.add(count)
            count+=1
        return domains

#generates constraints
    def generateConstraints(self,numberOfConstraints, variables):
      import random
      count = 0
      constraints = []
      while count < round(numberOfConstraints):
        #random selection of constrained variable
          constraint = random.sample(variables, 2)
          reversedConstraints = [constraint[0], constraint[1]]

          if not constraint in constraints and not reversedConstraints in constraints:
              constraints.append(constraint)
              count+=1
      return constraints 
      

#generates the final constraints and tupple pairs
    def constraintAndTupples(self,generatedConstratsList, generatedDomainsList, numberOfIncompactibleTuples):
      import random
      constraints = []
      tupples = []
      finalTuple = []
      count =0
      for item, value in enumerate(generatedConstratsList):
          constraint = generatedConstratsList[item]
          constraints.append(constraint)

          while count < numberOfIncompactibleTuples:
              tup = random.sample(generatedDomainsList, 2)

              if tup in tupples:
                  continue
              else:
                  tupples.append(tup)
                  count+=1
          finalTuple.append(tupples)
          tupples = []
          count = 0

      return finalTuple, constraints

"""## Input and Output

### User Input
To run this program, these input are espected from the user n, p, α and r

1.   number of variables(n)
2.   constraint tightness(p)
3.   constant(α)
4.   constant(r)

# Run Program
"""

#get input from the user from console
nVariables = input("Enter the number of variables\n")
print("...............................\n")

cTightness = input("Enter constraint tightness p 0 < p < 1  A number between 0 and 1\n")
print("...............................\n")

alpha =  input("Enter alpha constant p 0 < p < 1  A number between 0 and 1\n")
print("...............................\n")

beta = input("Enter beta constant p 0 < p < 1  A number between 0 and 1\n")
print("...............................\n")

#create the object of randonCSP
randomCSP = randomCSP(nVariables,cTightness,alpha,beta)

#get the domain size, number of constraints, number of incompactible tupples
domainSize,numberOfConstraints,numberOfIncompactibleTuples = randomCSP.computValues()

#generates out put for all the random csp values
generatedDomainsList = randomCSP.generateDomain(domainSize)
generatedVariables =  randomCSP.generateVariables(randomCSP.nVariables);
generatedConstratsList = randomCSP.generateConstraints(numberOfConstraints, generatedVariables)
finalTuple, constraints = randomCSP.constraintAndTupples(generatedConstratsList, generatedDomainsList, numberOfIncompactibleTuples)

"""# Output"""

#print random constraints and incompactible tupples
print("....................................................................")
print("..............USER INPUTS....................")
print("Number of variables: "+str(nVariables))
print("Constratint tightness: "+str(cTightness))
print("Alpha constant: "+str(alpha))
print("Beta constant: "+str(beta))
print("\n")
print("...............Generated Input......................................")
print("Size of Domain: "+ str(round(domainSize)))
print("number of incompactible tuples: "+str(round(numberOfIncompactibleTuples)))
print("Number of Constraints: "+str(round(numberOfConstraints)))
print('....................................................................')

for val,item in enumerate(constraints):
    print("{}  {}\n".format(constraints[val], finalTuple[val]))

#print(finalTuple)